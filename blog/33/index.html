<!doctype html>
<html lang="en-US" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">深入解读TuGraph计算引擎模型推理系统 | GeaFlow</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://kaiming-l.github.io/geaflow-website/blog/33"><meta data-rh="true" property="og:locale" content="en_US"><meta data-rh="true" property="og:locale:alternate" content="zh_CN"><meta data-rh="true" name="docusaurus_locale" content="en-US"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en-US"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="深入解读TuGraph计算引擎模型推理系统 | GeaFlow"><meta data-rh="true" name="description" content="TuGraph 计算引擎模型推理系统将基于迭代计算的图计算框架与模型推理系统相结合，推理系统可自定义推理依赖环境，图迭代计算与推理链路实现隔离。基于共享内存的跨进程通信方式，提高了推理数据交换效率，满足流图近线推理的时效性。在蚂蚁集团内部的实际应用场景中，大幅缩短了模型推理上线的链路与开发时间，用户迭代模型版本更方便快捷。"><meta data-rh="true" property="og:description" content="TuGraph 计算引擎模型推理系统将基于迭代计算的图计算框架与模型推理系统相结合，推理系统可自定义推理依赖环境，图迭代计算与推理链路实现隔离。基于共享内存的跨进程通信方式，提高了推理数据交换效率，满足流图近线推理的时效性。在蚂蚁集团内部的实际应用场景中，大幅缩短了模型推理上线的链路与开发时间，用户迭代模型版本更方便快捷。"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-05-24T00:00:00.000Z"><link data-rh="true" rel="icon" href="/geaflow-website/img/favicon.png"><link data-rh="true" rel="canonical" href="https://kaiming-l.github.io/geaflow-website/blog/33"><link data-rh="true" rel="alternate" href="https://kaiming-l.github.io/geaflow-website/blog/33" hreflang="en-US"><link data-rh="true" rel="alternate" href="https://kaiming-l.github.io/geaflow-website/zh-CN/blog/33" hreflang="zh-CN"><link data-rh="true" rel="alternate" href="https://kaiming-l.github.io/geaflow-website/blog/33" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://HO4M21RAQI-dsn.algolia.net" crossorigin="anonymous"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://kaiming-l.github.io/geaflow-website/blog/33","mainEntityOfPage":"https://kaiming-l.github.io/geaflow-website/blog/33","url":"https://kaiming-l.github.io/geaflow-website/blog/33","headline":"深入解读TuGraph计算引擎模型推理系统","name":"深入解读TuGraph计算引擎模型推理系统","description":"TuGraph 计算引擎模型推理系统将基于迭代计算的图计算框架与模型推理系统相结合，推理系统可自定义推理依赖环境，图迭代计算与推理链路实现隔离。基于共享内存的跨进程通信方式，提高了推理数据交换效率，满足流图近线推理的时效性。在蚂蚁集团内部的实际应用场景中，大幅缩短了模型推理上线的链路与开发时间，用户迭代模型版本更方便快捷。","datePublished":"2024-05-24T00:00:00.000Z","author":[],"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://kaiming-l.github.io/geaflow-website/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/geaflow-website/blog/rss.xml" title="GeaFlow RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/geaflow-website/blog/atom.xml" title="GeaFlow Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="GeaFlow" href="/geaflow-website/opensearch.xml">





<meta name="algolia-site-verification" content="4AB782AC2021573E">
<meta property="og:image" content="https://mdn.alipayobjects.com/huamei_tu4rvn/afts/img/A*PkdvSLd2A6kAAAAAQMAAAAgAep_eAQ/original"><link rel="stylesheet" href="/geaflow-website/assets/css/styles.202e52ef.css">
<script src="/geaflow-website/assets/js/runtime~main.0e03e885.js" defer="defer"></script>
<script src="/geaflow-website/assets/js/main.46ee6d68.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/geaflow-website/img/logo.png"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/geaflow-website/"><div class="navbar__logo"><img src="/geaflow-website/img/logo.png" alt="GeaFlow Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/geaflow-website/img/logo.png" alt="GeaFlow Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><div class="versionSelect_qA4O"><div class="versions_jk5T"><div class="selectItem_V7J8 selectItemActive_BNvF">0.0.2</div><div class="selectItem_V7J8">0.0.1</div></div><div class="current_ORt9">0.0.2</div></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link header-locale-dropdown"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_DSK9"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>English</a><ul class="dropdown__menu"><li><a href="/geaflow-website/blog/33" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="en-US">English</a></li><li><a href="/geaflow-website/zh-CN/blog/33" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="zh-CN">简体中文</a></li></ul></div><a href="https://github.com/apache/geaflow" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="navbarSearchContainer_dCNk"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div><div class="navbarCenter_ZzI1"> <a class="navbar__item navbar__link" id="docs" href="/geaflow-website/docs/guide">Docs</a><a class="navbar__item navbar__link" id="community" href="/geaflow-website/community/community">Community</a><a class="navbar__item navbar__link" href="/geaflow-website/download">Download</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/geaflow-website/blog">Blog</a><div class="navbar__item dropdown dropdown--hoverable"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/current-event.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://privacy.apache.org/policies/privacy-policy-public.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Privacy</a></li><li><a href="https://www.apache.org/security/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li><li><a href="https://www.apache.org/foundation/policies/conduct.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Code of Conduct</a></li></ul></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/29">GeaFlow 时序能力探秘——让时间数据焕发新生！</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/28">流图计算之增量match原理与应用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/30">Join性能变革：图数仓让SQL分析快人一步</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/32">流式图计算引擎 GeaFlow v0.6.4 发布，支持关系型访问图数据，增量匹配优化实时处理</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/31">Graph4Stream：基于图的流计算加速</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/27">Stream4Graph：动态图上的增量计算</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/geaflow-website/blog/33">深入解读TuGraph计算引擎模型推理系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/35">GeaFlow图数据集成：表到图的最后一公里</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/36">GeaFlow作业监控面板：运行时组件上的高效分析工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/34">GeaFlow交互式图查询：让图所见即所得</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2023</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/24">重磅发布！！！蚂蚁图团队开源高性能原生图存储系统CStore</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/25">GeaFlow交互式图查询：让图所见即所得</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/26">GeaFlow作业监控面板：运行时组件上的高效分析工具</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/23">世界第一！蚂蚁图计算TuGraph打破LDBC SNB-BI世界纪录</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/22">GeaFlow云原生部署：基于K8S Operator的轻量级作业启动方案</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/21">GeaFlow动态插件：快速集成大数据生态系统</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/20">开源TuGraph Analytics——是时候开始使用图计算了</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/18">TuGraph Analytics图计算快速上手之弱联通分量算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/19">TuGraph Analytics图建模研发：为图计算业务提速增效</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/17">容器内mysql无法启动解决方案</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/16">TuGgraph-Analytics图计算快速上手之紧密中心度算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/15">TuGraph Analytics流图计算之行为路径归因</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/14">为什么使用图进行关联运算比表Join更具吸引力？</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/13">TuGraph Analytics图计算快速上手之K-core算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/12">GeaFlow图计算快速上手之K-hop算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/10">GeaFlow任务能力增强：通过API定制流图计算逻辑</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/11">GeaFlow图计算快速上手之K-hop算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/9">分布式图计算如何实现？带你一窥图计算执行计划</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/8">GitHub上有哪些好项目？TuGraph-Analytics图计算快速上手之SSSP算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/7">图加速数据湖分析-TuGraph和Hudi集成</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/6">TuGraph图计算快速上手之PageRank算法</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/5">Kubernetes云原生实战：分布式TuGraph-Analytics实现图研发，构建第一个商业智能应用</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/4">从大数据到图计算-Graph On BigData</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/3">论文解读｜TuGraph Analytics 流式图计算论文入选国际顶会 SIGMOD</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/2">谁在以太坊区块链上循环交易？TuGraph+Kafka的0元流图解决方案</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/geaflow-website/blog/1">2023开放原子全球开源峰会，蚂蚁图计算平台开源业内首个工业级流图计算引擎</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">深入解读TuGraph计算引擎模型推理系统</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-05-24T00:00:00.000Z">May 24, 2024</time></div></header><div id="__blog-post-container" class="markdown"><p><font style="color:rgb(63, 63, 63)">TuGraph 计算引擎模型推理系统将基于迭代计算的图计算框架与模型推理系统相结合，推理系统可自定义推理依赖环境，图迭代计算与推理链路实现隔离。基于共享内存的跨进程通信方式，提高了推理数据交换效率，满足流图近线推理的时效性。在蚂蚁集团内部的实际应用场景中，大幅缩短了模型推理上线的链路与开发时间，用户迭代模型版本更方便快捷。<br>
</font></p>
<p><font style="color:rgb(63, 63, 63)">在计算机科学中，图是一种表示实体（节点或顶点）以及实体之间关系（边）的数据结构。图模型可以天然地描述网络结构，能更清晰地表达复杂的数据关系和依赖，简化关联数据的理解和分析。在不同的场景下，图中点边具备不同的语义信息。比如在资金交易场景下，每个人可以抽象成一个点表示，人与人之间的转账关系可以抽象成一条边表示。如下图，通过图数据模型反映出各个实体之间的资金往来关系，让数据的关联分析更加直观和高效。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792986725-25a2cf58-a7a2-411e-8845-6cecb9c29acd.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">资金交易图谱示例</font></p>
<p><font style="color:rgb(63, 63, 63)">在图数据模型上可以执行多种图算法，如社区检测，最短路径匹配，环路检测算法等。通过点边上的迭代计算，探索图模型中各个实体之间的关系。探索过程不依赖于数据的线性结构，从而便于识别隐藏的模式和关联关系。在主流迭代图算法中，节点通过消息传递的方式进行通信。每次迭代，节点可以接收来自它们邻居的消息，处理这些消息，然后</font><font style="color:rgb(63, 63, 63)">决</font><font style="color:rgb(63, 63, 63)">定是否发送新的消息给其他节点。迭代算法中，每个节点有一个状态，每次迭代它们都有可能更新这个状态直至收敛。例如，在 PageRank 算法中，每个节点的状态是其 PageRank 值，这个值在迭代过程中会随着邻居的值的更新而更新。</font></p>
<p><font style="color:rgb(63, 63, 63)">图迭代算法解决了经典的图计算问题，但随着业务需求的复杂度提升，基于迭代的图算法存在着表达能力不足、自适应性能力差、异质图处理难度大等缺点。近年来随着深度学习的研究和应用的发展，以图神经网络（Graph Neural Networks，GNNs）为代表的一类神经网络算法，被设计用来捕获图中实体（节点）和关系（边）间的复杂模式。图神经网络能够结合节点特征和图的结构来学习节点和边的表示，相比之下，传统的迭代图算法通常不会直接从原始特征中学习，而更多地专注于结构特征。依赖于深度学习的天然优势，GNNs 具有更强的表示学习能力，可以自动从数据中学习复杂的模式，这使得 GNNs 能够更好地处理多任务学习和迁移学习等问题。在社交网络分析、知识图谱、生物分子网络、推荐系统以及交通网络等领域，得到广泛应用。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792986790-9c0d8b8f-8c66-4589-b81e-15f8536956bf.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">GNN 算法示意</font></p>
<h1><font style="color:rgb(63, 63, 63)">2. 流图推理简介</font></h1>
<p><font style="color:rgb(63, 63, 63)">TuGraph 计算引擎（TuGraph Analytics[1]）是蚂蚁集团开源的大规模分布式实时图计算引擎（流图引擎），实现了流批一体的图计算模型，支持了丰富的图计算算法。GeaFlow 的流图计算能力，能处理连续输入的数据流，并支持增量的计算模式，极大得提高了数据的计算效率和实时性。GeaFlow 解决了业界大规模数据关联分析的实时计算问题，已广泛应用于数仓加速、金融风控、知识图谱以及社交推荐等场景。</font></p>
<p><font style="color:rgb(63, 63, 63)">随着业务场景中问题复杂度的提升，基于传统的迭代图算法已无法满足业务的实际需求。例如在反洗钱场景中，利用图神经网络算法处理复杂的交易关系，能够捕获到节点的局部图结构信息。通过聚合邻接节点的特征信息，每个交易节点都可以感知到周边图网络结构的信息。类似的图神经网络等 AI 模型的推理逻辑，是无法基于传统的图迭代计算模式直接高效地表达的。</font></p>
<p><font style="color:rgb(63, 63, 63)">受上述问题启发，我们思考是否可以将 GeaFlow 的流图计算能力与图神经网络等深度学习模型相结合，开发一套基于流图计算的模型推理系统。最终期望的推理系统具备如下能力：</font></p>
<ul>
<li><font style="color:rgb(63, 63, 63)">对于图算法工程师，在图迭代计算过程中，能够方便地使用机器学习模型的推理能力。</font></li>
<li><font style="color:rgb(63, 63, 63)">对于 AI 算法工程师，可以通过 GeaFlow 分布式流式计算的能力实现实时的模型推理。</font></li>
</ul>
<p><font style="color:rgb(63, 63, 63)">众所周知，在深度学习为代表的数据科学领域，Python 已经成为数据分析、模型训练和推理框架的主流开发语言，并提供了丰富的开发库和框架生态。而以 Hadoop 全家桶为代表的大数据计算引擎领域，基于 Java 语言开发的系统仍占据一席之地，当然 GeaFlow 也在其中。这种语言差异带来的“互操作性”成本，使得相当一部分大数据和 AI 生态组件无法轻松地融合，这也是 GeaFlow 支持图推理需要亟待解决的问题。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792986839-8eee4445-bb1b-4104-85f4-3bc15a5fc021.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">Java 与 Python 的生态融合</font></p>
<h1><font style="color:rgb(63, 63, 63)">3. 系统设计</font></h1>
<p><font style="color:rgb(63, 63, 63)">我们对业内的跨 Python &amp; Java 语言的方案进行了充分的调研，通过深入对比现有的跨语言交互方案的性能与效率，最终决定将模型推理任务运行于 Python 原生环境中以发挥出最佳的性能。</font></p>
<p><font style="color:rgb(63, 63, 63)">1. OONX</font></p>
<p><font style="color:rgb(63, 63, 63)">OONX 是一个开发的生态系统，为不同的机器学习框架之间提供一个标准的模型表示格式。它使得开发人员能够在不同的框架、工具、运行时环境之间以一种标准方式交换模型，从而简化了模型的迁移和部署。</font></p>

























<table><thead><tr><th><strong><font style="color:rgb(38, 75, 239)">优点</font></strong></th><th><strong><font style="color:rgb(38, 75, 239)">缺点</font></strong></th></tr></thead><tbody><tr><td><font style="color:rgb(63, 63, 63)">框架互操作性</font></td><td><font style="color:rgb(63, 63, 63)">转换成本高</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">生态系统支持</font></td><td><font style="color:rgb(63, 63, 63)">更新滞后</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">优化推理</font></td><td><font style="color:rgb(63, 63, 63)">版本兼容性</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">规范化模型格式</font></td><td><font style="color:rgb(63, 63, 63)">性能不一致</font></td></tr></tbody></table>
<p><font style="color:rgb(63, 63, 63)">2. Jython</font></p>
<p><font style="color:rgb(63, 63, 63)">以 Jython 为代表的方式，主要思想是在运行的宿主虚拟机上，使用宿主语言重新编写实现。</font></p>

























<table><thead><tr><th><strong><font style="color:rgb(38, 75, 239)">优点</font></strong></th><th><strong><font style="color:rgb(38, 75, 239)">缺点</font></strong></th></tr></thead><tbody><tr><td><font style="color:rgb(63, 63, 63)">Java 集成</font></td><td><font style="color:rgb(63, 63, 63)">版本管理复杂</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">跨平台</font></td><td><font style="color:rgb(63, 63, 63)">支持库有限</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">线程</font></td><td><font style="color:rgb(63, 63, 63)">更新滞后</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">-</font></td><td><font style="color:rgb(63, 63, 63)">支持 Python3 有限</font></td></tr></tbody></table>
<p><font style="color:rgb(63, 63, 63)">3. Py4j</font></p>
<p><font style="color:rgb(63, 63, 63)">Py4j 桥接库为代表的方式，以 Socket 通信模型为基础，实现 Python 和 Java 互相访问对象，方法，提供两个程序相互通信的能力。</font></p>

























<table><thead><tr><th><strong><font style="color:rgb(38, 75, 239)">优点</font></strong></th><th><strong><font style="color:rgb(38, 75, 239)">缺点</font></strong></th></tr></thead><tbody><tr><td><font style="color:rgb(63, 63, 63)">跨语言交互</font></td><td><font style="color:rgb(63, 63, 63)">网络传输</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">动态代理</font></td><td><font style="color:rgb(63, 63, 63)">部署分发难度大</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">支持复杂类型</font></td><td><font style="color:rgb(63, 63, 63)">版本难兼容</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">API 使用简易</font></td><td><font style="color:rgb(63, 63, 63)">运行时环境依赖复杂</font></td></tr></tbody></table>
<p><font style="color:rgb(63, 63, 63)">4. Web 服务化</font></p>
<p><font style="color:rgb(63, 63, 63)">Web 服务化是一种将机器学习模型部署成网络服务，调用者通过相应的 api 获取模型推理结果。</font></p>

























<table><thead><tr><th><strong><font style="color:rgb(38, 75, 239)">优点</font></strong></th><th><strong><font style="color:rgb(38, 75, 239)">缺点</font></strong></th></tr></thead><tbody><tr><td><font style="color:rgb(63, 63, 63)">扩展性好</font></td><td><font style="color:rgb(63, 63, 63)">性能差</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">简易且轻量</font></td><td><font style="color:rgb(63, 63, 63)">不适合计算密集型场景</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">社区支持</font></td><td><font style="color:rgb(63, 63, 63)">无状态管理</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">机器学习类库易集成</font></td><td><font style="color:rgb(63, 63, 63)">并发连接有限</font></td></tr></tbody></table>
<p><font style="color:rgb(63, 63, 63)">在 GeaFlow 模型推理系统的架构设计中，核心部分是通过 C++原生语言建立起来的一座桥梁，实现 Python 环境和 Java 虚拟机之间高效的数据交互和操作指令的传递。通过使用 C++作为媒介语言，我们不仅能够利用其接近硬件的执行效率，确保数据交互的性能，还能够保证在两个虚拟环境之间数据交换的计算精度和稳定性。基于共享内存的设计允许 Python 和 JVM 进程各自独立运行，既保证了运行环境的安全隔离，又能实现数据的高效共享。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792986716-5c2105c7-cbff-458b-84c6-6d511fc360e7.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">GeaFlow 模型推理系统设计</font></p>
<h1><font style="color:rgb(63, 63, 63)">4. 技术原理</font></h1>
<p><font style="color:rgb(63, 63, 63)">GeaFlow 模型推理系统工作流中，Driver 端（即控制节点）发挥着至关重要的角色。该节点运行在 Java 虚拟机进程，是整个推理流</font><font style="color:rgb(63, 63, 63)">程的控制中心。Driver 端初始化了一个非常关键的组件——InferenceContext 对象，InferenceContext 对象被设计为模型推理流程的核心，在 JVM 环境中创建并负责加载和预处理用户提供的模型文件和环境依赖信息。在模型推理任务之前，InferenceContext 会详细检查并准备好模型文件，确保能够正确加载到预期的执行环境中。InferenceContext 也负责初始化和配置与模型推理相关的虚拟环境，确保正确的 Python 环境或其他必要的运行时库得以安装和配置。</font></p>
<p><font style="color:rgb(63, 63, 63)">如图所示，由流式数据源源不断的触发图迭代计算与模型推理工作。TuGraph 计算引擎提供了 DeltaGraphCompute 计算接口，用户可自主定义增量图数据的处理逻辑，并更新历史的图存储(Graph Store)。通过 TuGraph 计算引擎模型推理系统，增量图迭代的中间计算结果，经过推理前置数据处理接口，并基于共享内存的跨进程通信方式，将处理后的数据流输入到推理进程，完成推理工作后的结果参与后续图迭代计算逻辑。下文将详细介绍各个数据接口的使用。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792986743-dc6cf33f-23a2-4a70-9f2c-aa9c9b8fa2da.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">流图推理工作流程</font></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="41-计算推理隔离"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">4.1 计算推理隔离</font><a href="#41-计算推理隔离" class="hash-link" aria-label="Direct link to 41-计算推理隔离" title="Direct link to 41-计算推理隔离">​</a></h2>
<p><font style="color:rgb(63, 63, 63)">在 GeaFlow 模型推理系统的架构中，集群的工作负载分配给多个 worker 节点。每个 worker 节点上运行着两个关键进程：负责图数据迭代计算的 Java 进程，以及执行模型推理的 Python 进程。为了充分利用计算系统的资源，推理进程在没有接收到推理请求时，会进入睡眠状态。这样的设计不仅减少了系统资源的占用，而且降低了系统的整体能耗。当推理请求到达时，推理进程会被立即唤醒，接收和执行新的推理任务。借助睡眠与唤醒机制以及智能的任务调度策略，可以保证系统能够以高效、稳定、节能的方式运行，同时满足了大规模图数据处理和实时推理的需求。</font></p>
<p><font style="color:rgb(63, 63, 63)">在每个 worker 工作节点下，按照不同的推理作业级别划分基础的虚拟环境，从而保证一个 wroker 节点也可以支持不同推理任务，支持标准的 requirements.txt 管理推理依赖库。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792987364-c77f0314-09ab-4ff3-8047-9d6d3d12b6b4.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">单机虚拟环境</font></p>
<p><font style="color:rgb(63, 63, 63)">在图迭代计算进程和推理进程之间通过数据队列实现双边数据的交互，通过在数据包的头文件中插入参数个数，长度等信息，推理进程在连续若干次收到空消息包后，将自动进入睡眠状态，释放 cpu 等资源。图迭代计算进程调用推理接口时，推理进程将快速退出睡眠状态，接收输入数据并完成推理流程。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792988026-796ff1bd-7af5-4b78-965c-b88e3e1a27d8.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">跨进程数据交互格式</font></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="42-跨进程数据交换"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">4.2 跨进程数据交换</font><a href="#42-跨进程数据交换" class="hash-link" aria-label="Direct link to 42-跨进程数据交换" title="Direct link to 42-跨进程数据交换">​</a></h2>
<p><font style="color:rgb(63, 63, 63)">对于推理数据的交换部分，底层通过 C++开发共享内存管理模块，实现两个进程之间的数据交互。在推理初始化阶段，由 InferenceContext 对象开辟进程共享内存，Java 进程负责创建并初始化推理（Python）进程，通知推理进程共享内存的地址信息，并映射到相应的进程。如图，Java 进程和推理进程均采用 C++作为桥梁语言，实现共享内存中数据的流动操作。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792987443-316faf5a-6578-4faf-ba84-939d0afb0e50.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">跨进程数据通信架构</font></p>
<p><font style="color:rgb(63, 63, 63)">在推理系统的性能测试阶段，我们发现推理进程读写进程时，接口的调用开销不容忽视。常规的理解认为 C++能够优化 Python 的执行效率，但前提是 Python 的执行内存足够复杂，优化执行内容的收益远大于接口的调用开销。然而，在我们系统设计中，共享内存的读写接口只是操作了内存地址，实现读写指针的移动。因此，接口的调用开销也是影响推理性能的关键因素，为此，我们充分调研了业界主流的方案。</font></p>





























<table><thead><tr><th><strong><font style="color:rgb(38, 75, 239)">解决方案</font></strong></th><th><strong><font style="color:rgb(38, 75, 239)">描述</font></strong></th></tr></thead><tbody><tr><td><font style="color:rgb(63, 63, 63)">CPython</font></td><td><font style="color:rgb(63, 63, 63)">C 语言实现 Python 及其解释器（JIT 编译器）</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">ctypes</font></td><td><font style="color:rgb(63, 63, 63)">Python 标准库</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">SWIG</font></td><td><font style="color:rgb(63, 63, 63)">开发工具，封装 native 程序接口</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">Pybind11/Boost.python/Nanobind</font></td><td><font style="color:rgb(63, 63, 63)">轻量级头文件库</font></td></tr><tr><td><font style="color:rgb(63, 63, 63)">Cython</font></td><td><font style="color:rgb(63, 63, 63)">Python 的超集，使用 C 语言特性，静态编译</font></td></tr></tbody></table>
<p><font style="color:rgba(0, 0, 0, 0.9)">如图所示，我们对比了多种 Python 调用 C 链接库的方案，性能是第一要素，因此选择 Cython 作为推理进程和底层内存交互的工具。Cython 是一个编程语言，是 Python 语言的一个超集，它将/C++的静态类型系统融合在了 Python 中，允许开发者可以在 Python 代码中直接使用 C 语言的特性，从而提高程序的执行效率。Cython 将 Python 源代码翻译为 C 或 C++代码，然后将其编译为二进制代码，能够显著提高数值计算和循环场景的代码执行性能。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792987773-faa65852-6287-4046-ab2b-b4e40fa4f88c.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">Python 调用 C 链接库方案性能对比</font></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="43-推理接口设计"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">4.3 推理接口设计</font><a href="#43-推理接口设计" class="hash-link" aria-label="Direct link to 43-推理接口设计" title="Direct link to 43-推理接口设计">​</a></h2>
<p><font style="color:rgba(0, 0, 0, 0.9)">上文介绍了采用 Cython 作为推理进程内存管理的链接工具，如下为 GeaFlow 模型推理系统的内存管理接口设计，提供了初始化，读和写三个接口。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9)">1. 初始化接口：负责共享内存地址的映射和读指针的初始化。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9)">2. 读接口：数据 bytes 的长度作为输入参数，直接在内存端上移动相应长度返回数据段，并移动到读指针。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9)">3. 写接口：将 bytes 和 bytes 长度写入到共享内存，并移动至写指针。</font></p>
<div class="language-plain codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">@cython.final</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">cdef class InferIpc:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cdef MmapIPC * ipc_bridge;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cdef uint8_t* read_ptr;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    def __cinit__(self, r, w):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.ipc_bridge = new MmapIPC(r, w)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        self.read_ptr = self.ipc_bridge.getReadBufferPtr()</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cpdef inline bytes readBytes(self, bytesSize):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if bytesSize == 0:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return b&quot;&quot;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cdef int readSize</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cdef int len_ = bytesSize</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        with nogil:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            readSize = self.ipc_bridge.readBytes(len_)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        if readSize == 0:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            return b&quot;&quot;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cdef unsigned char * binary_data = self.read_ptr</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return binary_data[:len_]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cpdef inline bool writeBytes(self, bytesBuf, length):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cdef bool writeFlag</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cdef int len_ = length</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cdef char* buf_ = bytesBuf</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        with nogil:</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            writeFlag = self.ipc_bridge.writeBytes(buf_, len_)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return writeFlag</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    def __dealloc__(self):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        del self.ipc_bridge</span><br></span></code></pre></div></div>
<p><font style="color:rgba(0, 0, 0, 0.9)">如下为用户实现推理的 Java 接口，同其它图迭代计算接口一样，需要推理的时候直接调用该接口，将图迭代的中间结果 inputs 发送到推理进程并返回模型结果。</font></p>
<div class="language-plain codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public interface GraphInferContext&lt;OUT&gt; extends Closeable {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    OUT infer(Object... inputs);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span><br></span></code></pre></div></div>
<h1><font style="color:rgb(63, 63, 63)">5. 最佳实践</font></h1>
<p><font style="color:rgba(0, 0, 0, 0.9)">我们以 PageRank 任务结合群组打分模型推理流程为例，演示具体的操作流程。</font></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="51-数据处理"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">5.1 数据处理</font><a href="#51-数据处理" class="hash-link" aria-label="Direct link to 51-数据处理" title="Direct link to 51-数据处理">​</a></h2>
<p><font style="color:rgba(0, 0, 0, 0.9)">定义推理数据前后置处理逻辑如下：</font></p>
<div class="language-plain codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">import abc</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import json</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import sys</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import os</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">import torch</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class MyInference(TransFormFunction):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    def __init__(self):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        super().__init__(2)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    def transform_pre(self, *args):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return args[0], args[1]</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    def transform_post(self, *args):</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        return args[0]</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="52-图迭代推理"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">5.2 图迭代推理</font><a href="#52-图迭代推理" class="hash-link" aria-label="Direct link to 52-图迭代推理" title="Direct link to 52-图迭代推理">​</a></h2>
<p><font style="color:rgba(0, 0, 0, 0.9)">定义图迭代计算结合推理逻辑如下：</font></p>
<div class="language-plain codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">public static class PRVertexCentricComputeFunction implements</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        IncVertexCentricComputeFunction&lt;Integer, Integer, Integer, Integer&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        private IncGraphComputeContext&lt;Integer, Integer, Integer, Integer&gt; graphContext;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        private IncGraphInferContext&lt;String&gt; inferContext;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void init(IncGraphComputeContext&lt;Integer, Integer, Integer, Integer&gt; graphContext) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            this.graphContext = graphContext;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            this.inferContext = (IncGraphInferContext&lt;String&gt;) graphContext;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void evolve(Integer vertexId,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                           TemporaryGraph&lt;Integer, Integer, Integer&gt; temporaryGraph) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            long lastVersionId = 0L;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            IVertex&lt;Integer, Integer&gt; vertex = temporaryGraph.getVertex();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            HistoricalGraph&lt;Integer, Integer, Integer&gt; historicalGraph = graphContext</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                .getHistoricalGraph();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (vertex == null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                vertex = historicalGraph.getSnapShot(lastVersionId).vertex().get();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (vertex != null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                List&lt;IEdge&lt;Integer, Integer&gt;&gt; newEs = temporaryGraph.getEdges();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                List&lt;IEdge&lt;Integer, Integer&gt;&gt; oldEs = historicalGraph.getSnapShot(lastVersionId)</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    .edges().getOutEdges();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                if (newEs != null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    for (IEdge&lt;Integer, Integer&gt; edge : newEs) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                        graphContext.sendMessage(edge.getTargetId(), vertexId);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                if (oldEs != null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    for (IEdge&lt;Integer, Integer&gt; edge : oldEs) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                        graphContext.sendMessage(edge.getTargetId(), vertexId);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void compute(Integer vertexId, Iterator&lt;Integer&gt; messageIterator) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            int max = 0;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            while (messageIterator.hasNext()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                int value = messageIterator.next();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                max = max &gt; value ? max : value;</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            IVertex&lt;Integer, Integer&gt; vertex = graphContext.getTemporaryGraph().getVertex();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            IVertex&lt;Integer, Integer&gt; historyVertex = graphContext.getHistoricalGraph().getSnapShot(0).vertex().get();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (vertex != null &amp;&amp; max &lt; vertex.getValue()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                max = vertex.getValue();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (historyVertex != null &amp;&amp; max &lt; historyVertex.getValue()) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                max = historyVertex.getValue();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            graphContext.getTemporaryGraph().updateVertexValue(max);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        @Override</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        public void finish(Integer vertexId, MutableGraph&lt;Integer, Integer, Integer&gt; mutableGraph) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            IVertex&lt;Integer, Integer&gt; vertex = graphContext.getTemporaryGraph().getVertex();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            List&lt;IEdge&lt;Integer, Integer&gt;&gt; edges = graphContext.getTemporaryGraph().getEdges();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (vertex != null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                mutableGraph.addVertex(0, vertex);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                graphContext.collect(vertex);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            } else {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                LOGGER.info(&quot;not found vertex {} in temporaryGraph &quot;, vertexId);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            if (edges != null) {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                edges.stream().forEach(edge -&gt; {</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                    mutableGraph.addEdge(0, edge);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">                });</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            List&lt;String&gt; inferInput = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            inferInput.add(String.valueOf(vertexId));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            inferInput.add(&quot;param2&quot;);</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            String infer = this.inferContext.infer(inferInput.toArray(new Object[]{0}));</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span><br></span></code></pre></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="53-创建作业"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">5.3 创建作业</font><a href="#53-创建作业" class="hash-link" aria-label="Direct link to 53-创建作业" title="Direct link to 53-创建作业">​</a></h2>
<p><font style="color:rgba(0, 0, 0, 0.9)">在 Console 作业管理平台创建一个 HLA 任务，上传图迭代计算 jar 包，模型文件和依赖管理文件。</font></p>
<p><img decoding="async" loading="lazy" src="https://intranetproxy.alipay.com/skylark/lark/0/2025/webp/96961/1756792987475-891e2894-bbf3-4f19-a139-243b73f59a9a.webp" alt="" class="img_ev3q"></p>
<p><font style="color:rgb(136, 136, 136)">创建图推理作业</font></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="54-配置参数"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239)">5.4 配置参数</font><a href="#54-配置参数" class="hash-link" aria-label="Direct link to 54-配置参数" title="Direct link to 54-配置参数">​</a></h2>
<p><font style="color:rgba(0, 0, 0, 0.9)">配置相关参数，启动运行作业即可。</font></p>
<div class="language-plain codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#bfc7d5;--prism-background-color:#292d3e"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-plain codeBlock_bY9V thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;geaflow.infer.env.enable&quot;:&quot;true&quot;,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 初始化虚拟环境等待时间</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;geaflow.infer.env.init.timeout.sec&quot;:120,</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 是否接收日志</span><br></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;geaflow.infer.env.suppress.log.enable&quot;:&quot;true&quot;</span><br></span></code></pre></div></div>
<h1><font style="color:rgb(63, 63, 63)">6. 总结</font></h1>
<p><font style="color:rgba(0, 0, 0, 0.9)">通过将 AI 模型推理引入 GeaFlow 流图计算系统，让我们能够对图数据进行深度地分析和预测。利用最新的机器学习和深度学习技术，TuGraph Analytics 图计算引擎不仅可以对图数据进行分类和回归分析，还可以预测未来趋势，从而在多个维度上提供决策支持。</font></p>
<p><font style="color:rgba(0, 0, 0, 0.9)">希望通过以上的介绍，可以让大家对 GeaFlow 模型推理系统有个比较清晰的了解，非常欢迎大家加入我们社区（<a href="https://github.com/TuGraph-family/tugraph-analytics%EF%BC%89%EF%BC%8C%E4%B8%80%E8%B5%B7%E6%9E%84%E5%BB%BA%E5%9B%BE%E6%95%B0%E6%8D%AE%E4%B8%8A%E7%9A%84%E6%99%BA%E8%83%BD%E5%8C%96%E5%88%86%E6%9E%90%E8%83%BD%E5%8A%9B%EF%BC%81" target="_blank" rel="noopener noreferrer">https://github.com/TuGraph-family/tugraph-analytics），一起构建图数据上的智能化分析能力！</a></font></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="引用链接"><font style="color:rgb(38, 75, 239)">引用链接</font><a href="#引用链接" class="hash-link" aria-label="Direct link to 引用链接" title="Direct link to 引用链接">​</a></h4>
<p><code>&lt;font style=&quot;color:rgb(63, 63, 63);&quot;&gt;[1]&lt;/font&gt;</code><font style="color:rgb(63, 63, 63)"> TuGraph Analytics: </font><em><font style="color:rgb(63, 63, 63)"><a href="https://github.com/TuGraph-family/tugraph-analytics" target="_blank" rel="noopener noreferrer">https://github.com/TuGraph-family/tugraph-analytics</a></font></em></p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/geaflow-website/blog/27"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Stream4Graph：动态图上的增量计算</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/geaflow-website/blog/35"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">GeaFlow图数据集成：表到图的最后一公里</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#41-计算推理隔离" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">4.1 计算推理隔离</font></a></li><li><a href="#42-跨进程数据交换" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">4.2 跨进程数据交换</font></a></li><li><a href="#43-推理接口设计" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">4.3 推理接口设计</font></a></li><li><a href="#51-数据处理" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">5.1 数据处理</font></a></li><li><a href="#52-图迭代推理" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">5.2 图迭代推理</font></a></li><li><a href="#53-创建作业" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">5.3 创建作业</font></a></li><li><a href="#54-配置参数" class="table-of-contents__link toc-highlight"><font style="color:rgb(255, 255, 255);background-color:rgb(38, 75, 239);">5.4 配置参数</font></a></li></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/geaflow-website/docs/quick_start/quick_start">Quick Start</a></li><li class="footer__item"><a class="footer__link-item" href="/geaflow-website/docs/deploy/install_guide">Deployment</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/geaflow-website/community/how_to_contribute">Contribute</a></li><li class="footer__item"><a class="footer__link-item" href="/geaflow-website/community/how_to_release">Realease</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://tugraph.tech" target="_blank" rel="noopener noreferrer" class="footer__link-item">TuGraph<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://github.com/apache/geaflow" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div></div></footer></div>
</body>
</html>